<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DOM MANITPULATION NOTES</title>
  </head>

  <body>
    <style>
      body {
        background-color: lightseagreen;
        color: #ffff;
      }
 
      h2 {
        font-size: 2rem;
      }
      p {
        font-size: 1.5rem;
        display: flex;
        justify-content: center;
        font-weight: bold;
      }
      code{
        font-size: 1rem;
        font-weight: bold;
        margin-top: 7px;
      }
      h2 {
        display: flex;
        justify-content: center;
      }
      .container {
        margin-top: 40px;
        border: 1px solid white;
        width: 700px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    align-items: center;
    margin: auto;
    padding: 40px;
  
      }
      li{
        font-size: 1.5rem;
      }
  
      @media screen and (max-width: 760px) {
        .container {
          width: 70%;
        }
        h1{
            margin-left: 40px
        }
      }

    </style>
    <div class="container">
      <h1>
        <u>
          <b> Notes for DOM MANIPULATION </b>
        </u>
      </h1>
    </div>
    <div class="container">
      <h2>The Global "window" & "document" Objects [Day 33]</h2>
      <p>So let's get started, 
        when we work with the DOM we'll always use these 
        two global variables
      </p>
      <p>
        <ul>
            <li>
                window
            </li>
            <li>
                document
            </li>
        </ul>
      </p>
      <p>
        These variables store objects inside them, and 
        they in turn contain built in functions
      </p>
      <p>
        The global window object itself holds information 
        and functionality related to the active browser window 
        & tab
      </p>
      <p>
        If we console.log(window) in our js file, the 
        console will display all the properties and 
        methods inside of the window object, don't 
        be intimidated, most developers won't need to know 
        all the properties and methods of the window object 
        by heart 
      </p>
      <p>
        The main object we'll use frequently is the 'document'
        object, or the document property on the window object
      </p>
      <p>
        This document object is a 'nested object' because 
        it's an object inside of another object
      </p>
      <p>
        And this document onject contains info and functionality 
        of the loaded website content
      </p>
      <p>
        This is what allows us to gain access to 
        html elements with methods like:
      </p>
      <ul>
        <li>
            getElementById()
        </li>
        <li>
            getElementByClassName()
        </li>
      </ul>
    </div>
    <div class="container">
        <h2>
            What is the "DOM"?
        </h2>
        <p>
            DOM stands for DOCUMENT OBJECT MODEL, 
            which basically is just what the website looks 
            like in it's totality, what the browswer parses 
            and renders, what we see
        </p>
        <p>
            So every single html element we create, this 
            paragraph tag I'm writing notes inside of right 
            at this very moment, is translated to a 
            javascript object 
        </p>
        <p>
            And since we have javascript representation 
            of our html code, we can select things from 
            our html in javascript and modify them
        </p>
        <p>
            And the 'door' that gives us access to the 
            html elements is the 'document' window object
        </p>
        <p>
            Through the document object we access the DOM
        </p>
        <p>
            This is important, since any time we want to 
            dynamically render things in real time on our 
            web site or app, we need to understand how to 
            manipulate the DOM
        </p>
    </div>
    <div class="container">
        <h2>
            Exploring the DOM
        </h2>
        <p>
            The Document object, or the "document" property on the window, 
            is our gateway to the DOM, to view some of these properties, 
            we can use "console.dir(document)" and we'll be able to view 
            in more detail everything accessible for DOM MANIPULATION
        </p>
        </div>
        <div class="container">
        <h2>
            Drilling into the DOM to select and modify elements
        </h2>
        <p>
            In this sections we're going to bend the DOM to our 
            specifications by accessing elements inside of it with 
            JavaScript
        </p>
        <p>
         Max just showed an interesting thing, when we link 
         our script in our html, it's normally placed at the very 
         bottom of our body
        </p>
          <p>
            However, we can use the boolean attribute 'defer' right after our "src=index.js" defer
           </p>
           <p>
             This Boolean attribute is set to indicate to a browser
              that the script is meant to be executed after the
               document has been parsed, but before 
               firing DOMContentLoaded.
               </p>
               <p>
            Scripts with the defer attribute will prevent the
             DOMContentLoaded event from firing until the script 
             has loaded and finished evaluating.
            </p>
            <p>
            This attribute must not be used if the src attribute is absent
             (i.e. for inline scripts),
             in this case it would have no effect.
            </p>
            <p>
            To achieve a similar effect for dynamically inserted 
            scripts use async="false" instead. Scripts with
             the defer attribute will execute in the order
              in which they appear in the document.
          </p>
    </div>
    <div class="container">
        <h2>
            The DOM Tree
        </h2>
        <p>
        The DOM itself is like a tree of nested JavaScript objects

        </p>
        <p>
            The 'document' is like the top of the tree, then 
            theres's the body and head which are branches on the same level, 
            then below the body we have our elements which are all branches at 
            the same level, then anything nested inside those h1, p, or 
            whichever tag are another level below, and it's like that all the 
            way down
        </p>
    </div>
    <div class="container">
        <h2>
            "drilling into elements" vs Query selectors
        </h2>
        <p>
            As we can see we can use things like:
        </p>
        <p>
            document.body.children[1].children[0].href = 'https://google.com';
        </p>
        <p>
            To drill deep into the DOM to select what we'd like, but there 
            are easier ways to do this, with query selectors:
        </p>
        <p>
            document.getElementById('some-id')
        </p>
        <p>
            or
        </p>
        <p>
            document.getElementByClassName('some-classname')
        </p>
        <p>
            Or
        </p>
        <p>
            document.querySelector('.some-class')
        </p>
    </div>
    <div class="container">
        <h2>
            Main Differences
        </h2>
        <p>
            querySelector* is more flexible, as you can pass it any CSS3 selector,
             not just simple ones for id, tag, or class.
        </p>
        <p>
            The performance of querySelector* changes with the size of the DOM that
             it is invoked on. To be precise, querySelector* calls run in O(n) time 
             and getElement* calls run in O(1) time, where n is the total number 
            of all children of the element or document it is invoked on.
        </p>
        <p>
            The return types of these calls vary. querySelector and 
            getElementById both return a single element. querySelectorAll and 
            getElementsByName both return NodeLists. The older 
            getElementsByClassName and getElementsByTagName both return
             HTMLCollections. NodeLists
             and HTMLCollections are both referred to as collections of elements.
        </p>
        <p>
            Collections can return "live" or "static" collections respectively. 
            This is NOT reflected in the actual types that they return. getElements*
             calls return live collections, and querySelectorAll returns a static 
             collection. The way that I understand it, live collections contain 
             references to elements in the DOM, and static collections contain 
             copies of elements. Take a look at @Jan Feldmann's comment's below for
              a different angle as well. I haven't figured out a good way to
             incorporate it into my answer but it may be a more accurate 
             understanding.
        </p>
        <code>Function               | Live? | Type           | Time Complexity
            </code>
            <code>
            querySelector          |       | Element        |  O(n)
            </code>
            <code>
            querySelectorAll       |   N   | NodeList       |  O(n)
            </code>
            <code>
            getElementById         |       | Element        |  O(1)
            </code>
            <code>
            getElementsByClassName |   Y   | HTMLCollection |  O(1)
            </code>
            <code>
            getElementsByTagName   |   Y   | HTMLCollection |  O(1)
            </code>
            <code>
            getElementsByName      |   Y   | NodeList       |  O(1)
            </code>
    </div>

    <div class="container">
        <p>
            The main advantage of things like document.getElementById() and 
            document.querySelector() is that we don't need to delve as deeply 
            into the depths of the DOM tree, we can individually or group select 
            HTML elements using class names and id's
        </p>
        <p>
            These will serve as the primary ways we'll traverse the DOM, 
            it's important to remember how to drill into elements as a practice,
            since it can illustrate the structure of the DOM at a deeper level
        </p>
    </div>
    <div class="container">
        <p>
            Common Query Methods [Day 34]
            </p>
            <p>
When it comes to querying / selecting HTML elements via JavaScript, 
there are a couple of commonly used built-in methods that
 are worth knowing:
</p>
<p>
document.getElementById('some-id'): Select a HTML element by its
 ID (selects only one element, since IDs should be unique)
</p>
<p>
document.querySelector('< some-css-selector>'): Selects
 the first matching (!) HTML element that is met / selected
  by the provided CSS selector; The CSS selector can basically 
  be any kind of valid CSS selector (e.g. ID selector, tag type 
  selector, class selector, combined selectors etc.)
< /some-css-selector>
</p>
<p>
document.querySelectorAll('< some-css-selector>'): 
Selects ALL matching HTML elements that are met / 
selected by the provided CSS selector
</p>
<p>
There also are a few lesser used selection methods,
 that you also should've heard about:
</p>
<p>
document.getElementsByClassName('some-css-class'): 
Selects all HTML elements that have the provided CSS class
</p>
<p>
document.getElementsByTagName('tag'): 
Selects all HTML elements that are of the provided HTML tag type
        </p>
    </div>
  </body>
</html>
